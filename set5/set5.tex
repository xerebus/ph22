\documentclass{article}
\input{../../preamble.tex}

\usepackage{fancyhdr}
\usepackage{cancel}
\usepackage[margin=1in, headheight=50pt]{geometry}
\pagestyle{fancy}
\lhead{\textbf{Ph22 Set 5}}
\chead{}
\rhead{Aritra Biswas}
\setlength{\headsep}{20pt}

\begin{document}

\section{Introduction}

We build on the framework developed in Ph 22.3. Instead of the brute-force
calculation of pairwise forces, we use the Barnes-Hut quadtree algorithm
to clump together far-away gravitational sources.

\subsection{Implementation choices}

A \texttt{QuadTree} class was created to hold the Barnes-Hut tree.
The tree is composed of \texttt{QuadNode} objects, which hold their member
particles, their total mass, their effect center of mass, and pointers to
their children if they exist. The \texttt{RootNode} object is a special
subclass of \texttt{QuadNode}, containing special initialization routines
since it is the only node not generated by calling \texttt{QuadNode.split()}
on a parent node. The \texttt{QuadNode.split()} and
\texttt{QuadNode.calculate()} methods are recursive, so calling them on
the root node initializes the whole tree.

The tree is recreated at each evolution step, used for calculation of the
net force on each particle, and then deleted for minimal memory usage.
The repeated access to this tree is an important optimization concern.
When implementing this algorithm in a lower-level language like C,
cache-optimizing the \texttt{QuadTree} could lead to huge performance
improvements.

\subsection{Opening angle}

The Barnes-Hut quadtree algorithm uses an opening angle $\theta$ to
determine the level of approximation. When computing the force that the
particles inside a given quadtree node exert on a test particle, we compare
the size $l$ of the quadtree node (an upper bound on the distances between
the particles in this group) to the distance $d$ from the group of particles
to the test particle. If $l/d < \theta$, the group is considered far enough
away that it can be approximated as a single particle.

Thus, $\theta = 0$ gives us the exact brute-force calculation, and higher
$\theta$ means fewer calculations through more approximation. We aim
to find a suitable $\theta$ that balances speed with accuracy,
as well as study the behavior of the system with $\theta$.

\section{Qualitative observations}

Qualitative observations were conducted on a system of $N = 30$ particles
visualized using \texttt{vpython}. Large variations in $\theta$ were used
to emphasize visual differences; more careful study follows below.

$\theta = 1$ yielded a notable performance improvement over the brute-force
approach, but the effects of clumping were quite visible. Particle motion
seemed quite unnatural compared to the exact brute-force solution: it
seemed as if there was an invisible larger mass in a small orbit
near the center of the system influencing the motion of all the other
particles. This behavior could be explained by considering the
extreme $\theta \gg 1$ limit: all particles would be grouped, and each
particle would be attracted to the center of mass of the entire system.

A short visualization with $\theta = 5$ yielded complete disaster, with
all particles quickly moving off-screen. This behavior is
unsurprising given our examination of the $\theta \gg 1$ limit: the
particles' motion is highly coupled because all are attracted to the center
of mass, so motion of the center of mass is amplified: particles follow
the center of mass, moving the center of mass further in the direction in
which it was originally going.

\section{Quantitative analysis}

Figure \ref{times.pdf} shows the algorithm's wall-clock runtime for various
opening angles. As expected, the performance increases dramatically with
$\theta$, although the log plot shows that the dependence is slower than
exponential decay. Figure \ref{energies.pdf} shows the energy evolution
for various $\theta$.

\plop{times.pdf}{Wall time of the Barnes-Hut algorithm on $N = 100$
particles randomly distributed in an unit circle with unit speeds for
various opening angles.}

\plop{energies.pdf}{Evolution of the total energy of the gravitational
system with $N = 100$ for various opening angles $\theta$.}

As a measure of approximation error, we use an estimate
of the average energy of the $N = 100$ system over the computed period.
This average is estimated by sampling at the timesteps plotted in
Figure \ref{energies.pdf}. Here, we find an optimal $\hat\theta = 0.1$:
\begin{align}
    \ev{E}_{\theta = 0} = -21500.289563
    \sp{}
    \ev{E}_{\theta = 0.1} = -21400.060124
    \sp{}
    \text{\% error} = 0.466\%.
\end{align}
We have achieved a 13.4\% performance boost with 0.5\% error.



\end{document}
